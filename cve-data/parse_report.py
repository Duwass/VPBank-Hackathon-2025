import pandas as pd
import os
import argparse
import json

def normalize_os_name(os_str):
    if pd.isna(os_str):
        return ""
    return str(os_str).lower().replace("_", " ").strip()

# === CLI ARGUMENTS ===
parser = argparse.ArgumentParser(description="Parse CVE report and extract KBs for top CVEs by group")
parser.add_argument("--input", default="cve_input_100.xlsx", help="Path to CVE report Excel file")
parser.add_argument("--kb_dir", default="kb_reports", help="Directory containing CVE-specific KB Excel files")
parser.add_argument("--group_by", default="OS", help="Column to group by (e.g., OS, Hostname, Server IP)")
parser.add_argument("--output", default="top_kbs_by_group.json", help="Path to save output JSON")
parser.add_argument("--min_score", type=float, default=0.0, help="Minimum CVE Score to include")
args = parser.parse_args()

# === LOAD INPUT ===
df = pd.read_excel(args.input)

# === PREPROCESS ===
# Normalize column names
df.columns = df.columns.str.strip()

# Fix CVE Score values like "6,8" to "6.8"
df["CVE Score"] = (
    df["CVE Score"]
    .astype(str)
    .str.replace(",", ".", regex=False)
    .astype(float)
)

# Filter by min score
df = df[df["CVE Score"] >= args.min_score].reset_index(drop=True)

# Normalize OS for matching
df["normalized_os"] = df["OS"].apply(normalize_os_name)

# === MAIN LOGIC ===
result = {}

for group_value, group_df in df.groupby(args.group_by):
    if group_df.empty:
        print('no data')
        continue

    group_key = str(group_value)
    sorted_group = group_df.sort_values(by="CVE Score", ascending=False)

    # Try each CVE in descending score order until a KB report is found
    top_row = None
    kb_file = None

    for _, row in sorted_group.iterrows():
        cve_id_candidate = row["CVE"]
        kb_candidate = os.path.join(args.kb_dir, f"{cve_id_candidate}_KB_Report.xlsx")

        if os.path.exists(kb_candidate):
            top_row = row
            kb_file = kb_candidate
            print(f"[✓] Found KB report for {cve_id_candidate} in group '{group_key}'")
            break
        else:
            print(f"[!] KB report not found for {cve_id_candidate}")

    if top_row is None or kb_file is None:
        print(f"[!] Skipping group '{group_key}' — no KB report found for any CVE")
        continue

    cve_id = top_row["CVE"]
    print(f"Processing group '{group_key}' with CVE {cve_id} (Score: {top_row['CVE Score']})")

    try:
        kb_df = pd.read_excel(kb_file)
        kb_df.columns = kb_df.columns.str.strip()
        kb_df["normalized_os"] = kb_df["OS"].apply(normalize_os_name)

        # Match by normalized OS
        match = kb_df[kb_df["normalized_os"].str.contains(top_row["normalized_os"], na=False)]
        if match.empty:
            print(f"[!] No KB match for {cve_id} in group '{group_key}' with OS '{top_row['OS']}'")
            continue

        kb_list = [
            {
                "KB": str(row["Patch"]).strip(),
                "Title": str(row["Title"]).strip()
            }
            for _, row in match.iterrows()
        ]

        result[group_key] = {
            "CVE": cve_id,
            "CVE Score": float(top_row["CVE Score"]),
            "KBs": kb_list
        }
    except Exception as e:
        print(f"[!] Error processing {kb_file}: {e}")

# === OUTPUT ===
if result:
    with open(args.output, "w", encoding="utf-8") as f:
        json.dump(result, f, indent=2)
    print(f"[✓] Output saved to {args.output}")
else:
    print("[!] No data matched. JSON not written.")

# python3 parse_report.py --input ./cve_input_100.xlsx --output ./output/patch.json --kb_dir ./output --group_by OS --min_score 7.0